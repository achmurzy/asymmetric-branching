source("asymmetric_analysis.R")

length_ratio_def = 0.3
length_ratio_sim = seq(0.1, 1, by=0.1)

radius_ratio_def = 0.5
radius_ratio_sim = seq(0.25, 0.75, by=0.05)

length_asym_ratio_def = 0
length_asym_ratio_sim = seq(-0.5, 0.5, 0.1)

radius_asym_ratio_def = 0
radius_asym_ratio_sim = seq(-0.5, 0.5, 0.1)

root_length_def = 1000
root_length_sim = seq(100, 1000, by=100) 

root_width_def = 100
root_width_sim = seq(10, 100, by=10)

leaf_length_def = 10
leaf_length_sim = seq(0.1, 10, by=0.1)

leaf_width_def = 1
leaf_width_sim = seq(0.01, 1, by=0.01)

root <- list(L=root_length_def, R=root_width_def)
petiole <- list(L=leaf_length_def, R=leaf_width_def)

epiphyte_length_def = 1
epiphyte_lingth_sim = seq(1, 100, by=1)

epiphyte_radius_def = 0.1
epiphye_radius_sim = seq(0.1, 10, by = 0.1)

build_child_branches <- function(tree, p_id, counter, pos)
{
  #print(counter)
  #print(tree[counter,])
  #print(typeof(tree[counter,]$LENGTH))
  #print(typeof(tree[counter,]$GAMMA))
  if(pos)
  {
    len = tree[p_id,]$LENGTH * (tree[p_id,]$GAMMA + tree[p_id,]$D_GAMMA)
    rad = tree[p_id,]$RADIUS * (tree[p_id,]$BETA + tree[p_id,]$D_BETA)
  }else
  {
    len = tree[p_id,]$LENGTH * (tree[p_id,]$GAMMA - tree[p_id,]$D_GAMMA)
    rad = tree[p_id,]$RADIUS * (tree[p_id,]$BETA - tree[p_id,]$D_BETA)
  }
  
  gamma = tree[p_id,]$GAMMA
  beta = tree[p_id,]$BETA
  
  d_gamma = tree[p_id,]$D_GAMMA
  d_beta = tree[p_id,]$D_BETA
  
  order = tree[p_id,]$BRANCH_ORDER
  
  #Branch exceeds at least one leaf dimension
  if(len > tree[nrow(tree),]$LENGTH && rad > tree[nrow(tree),]$RADIUS)
  {
      counter = counter + 1
      tree[counter,] <- list(order+1, counter, "", paste(p_id), 0, 0, 0, len, rad, beta, gamma, d_beta, d_gamma, 0, 0, TRUE)
      p_id = counter
         
      c_1 = counter + 1
      res <- build_child_branches(tree, p_id, counter, TRUE)
      tree <- res$data
      counter <- res$counter
      if(counter < c_1)
      { c_1 = "" }
      
      c_2 = counter + 1
      res <- build_child_branches(tree, p_id, counter, FALSE)
      tree <- res$data
      counter <- res$counter
      if(counter < c_2)
      { c_2 = "" }
      
      tree[p_id,]$CHILD_IDS <- paste(c_1, c_2, sep="_")
  }else
  {
    print("Branch dimensions too small")
  }
  
  return (list("data"=tree, "counter"=counter))
}

build_asymmetric_tree <- function(trunk=root, leaf=petiole, beta=radius_ratio_def, gamma=length_ratio_def, 
                                  d_beta=radius_asym_ratio_def, d_gamma=length_asym_ratio_def)
{
  counter = 1
  
  #Compute dimensions based on trunk and leaves
  #assumes asymmetry parameters positive and less than symmetry parameters
  len <- log(leaf$L/trunk$L)/log(gamma - d_gamma)
  rad <- log(leaf$R/trunk$R)/log(beta - d_beta)
  order <- ceiling(max(len, rad))
  
  #print("Tree info: ")
  #print("\tMax branch order: ")
  #print(order)
  #print("\tRoot dimensions:")
  #print(trunk)
  #print("\tLeaf Dimensions:")
  #print(leaf)
  
  #Estimate rows needed based on minimum branch order
  branches <- sum(2 ^ seq(0, order-1))
  tree <- make_internal_frame(branches+1)
  
  tree[1,] <- list(1, 1, "2_3", "0", 0, 0, 0, trunk$L, trunk$R, beta, gamma, d_beta, d_gamma, 0, 0, TRUE)
  tree[nrow(tree),] <- list(1, 1, "", "", 0, 0, 0, leaf$L, leaf$R, beta, gamma, d_beta, d_gamma, 0, 0, FALSE)
  
  c_1 = counter+1
  res <- build_child_branches(tree, 1, counter, TRUE)
  tree <- res$data
  counter <- res$counter
  if(counter < c_1)
  { c_1 = "" }
  
  tree <- res$data
  counter <- res$counter
  
  c_2 = counter+1
  res <- build_child_branches(tree, 1, counter, FALSE)
  tree <- res$data
  counter <- res$counter
  if(counter < c_2)
  { c_2 = "" }
  
  tree[1,]$CHILD_IDS <- paste(c_1, c_2, sep="_")
  tree <- tree[which(tree$POS),]
  return(tree)
}

centripetal_ordering_scheme <- function(tree)
{
  children <- as.integer(which(tree$CHILD_IDS == "_"))
  tree[children,]$BRANCH_ORDER = 0
  orders <- tree[children,]$BRANCH_ORDER
  zeros <- children != 0
  while(zeros[1])
  {
    children <- as.integer(get_children(tree[children,]$PARENT_ID))
    zeros <- children != 0
    
    children <- children[zeros]
    orders <- orders[zeros]
    
    tree[children,]$BRANCH_ORDER <- orders + 1
    orders <- tree[children,]$BRANCH_ORDER
  }
  return(tree)
}

#Performs binomial experiment across tree hierarchy with continuous distribution
#Default to Poisson process - exponential distribution - density function only, or
tree_distribution <- function(tree, cd=dexp, trials=1)
{
  size <- range(tree$BRANCH_ORDER)
  tree_mask <- vector(mode="list", length=(size[2]+1))
  names(tree_mask) <- as.character(seq(size[1], size[2]))

  for(i in size[1]:size[2])
  {
    rows <- which(tree$BRANCH_ORDER == i)
    n = length(rows)
    pr = cd(i)
    tree_mask[[as.character(i)]] <- rbinom(n, trials, prob=pr)
  }
  return(tree_mask)
}

distribute_food <- function(tree)
{
  mask <- tree_distribution(tree)
  size <- range(tree$BRANCH_ORDER)
  tree <- cbind(tree, FOOD=-1)
  for(i in size[1]:size[2])
  {
    rows <- which(tree$BRANCH_ORDER == i)
    tree[rows,]$FOOD <- mask[[as.character(i)]]
    print(mask[[as.character(i)]])
  }
  return(tree)
}

distribute_nests <- function(tree)
{
  mask <- tree_distribution(tree)
  size <- range(tree$BRANCH_ORDER)
  tree <- cbind(tree, NEST=-1)
  for(i in size[1]:size[2])
  {
    rows <- which(tree$BRANCH_ORDER == i)
    tree[rows,]$NEST <- mask[[as.character(i)]]
    print(mask[[as.character(i)]])
  }
  return(tree)
}

build_epiphytic_forest <- function()
{
  
}
